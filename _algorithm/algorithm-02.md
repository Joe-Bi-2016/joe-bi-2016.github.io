---
title: "你真的理解KMP算法吗"
collection: algorithm
permalink: /algorithm/algorithm-02
excerpt: ' '
date: 2024-05-31
citation: 'Joe-Bi. (2024). &quot;KMP算法的本质.&quot; <i>GitHub Joe-Bi of Bugs</i>'
---



我们知道kmp算法是现在字符串匹配、查找等最好的算法，看了很多写kmp算法的文章，但我个人觉得几乎没有一个人真的讲清楚了这个算法的核心。

我一直有个观点：对一件事你如果真的懂了，是能一句话讲出这个事物的本质的。算法更是如此。你只有真正懂了，高度抽象化了，形成了自己的思维，才能将这种思想进行迁移，解决更多的场景和问题。


## KMP算法概述

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth、J.H.Morris和V.R.Pratt提出，因此也被称为克努特—莫里斯—普拉特算法（简称KMP算法）。

### 算法核心
减少匹配次数：KMP算法的核心思想是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数，以达到快速匹配的目的。
next()函数：具体实现上，KMP算法通过一个名为next()的函数来实现，这个函数包含了模式串的局部匹配信息。

### 算法原理
从主字符串的第一个字符开始：KMP算法从主字符串的第一个字符开始，将其与子字符串的第一个字符进行比较。
相等与不等的情况：如果字符相等，则继续比较后续字符；如果不等，则根据部分匹配表（即next数组）的值，将子字符串向右移动若干个字符，然后再次进行比较。

### 算法效率
时间复杂度：KMP算法的时间复杂度为O(m+n)，其中m和n分别是模式串和主串的长度。相较于O(n^2)的暴力匹配算法，KMP算法具有较高的效率。

### 算法应用
模式匹配：KMP算法主要用于在目标字符串（主串）中快速查找一个给定的模式串，并确定其出现的位置。

DNA序列比对：在生物信息学中，KMP算法可以快速地查找出两个DNA序列中的相同部分，并进行相应的比对操作。

数据库查询：KMP算法可以高效地在数据库中查找出满足条件的数据。

数据压缩：KMP算法可以高效地找出字符串中的重复模式，从而进行相应的压缩操作。

## KMP算法的本质

从上面的介绍看，理解计算next数组是核心。next数组是匹配串的一个查找表，它的定义可以用下面一句话来解释，就是kmp算法的本质：

### <font face="黑体" color=red size=5><u>*next数组的每个元素表示匹配串中从起始到以当前字符结尾的子串中以当前字符结尾的连续重复最长串长度。eg:*</u></font>

字符串abcdabe,len是每个子串以最后一个字符结尾的连续重复最长串长度：

next[0] = 0 // 子串'a'中没有包含以'a'结尾的连续重复子串，len = 0  
next[1] = 0 // 子串'ab'中没有包含以'b'结尾的连续重复子串，len = 0  
next[2] = 0 // 子串'abc'中没有包含以'c'结尾的连续重复子串，len = 0  
next[3] = 0 // 子串'abcd'中没有包含以'd'结尾的连续重复子串，len = 0  
next[4] = 1 // 子串'abcda'中包含以'a'结尾的连续重复子串是'a'，len = 1  
next[5] = 2 // 子串'abcdab'中包含以'b'结尾的连续重复子串'ab'，len = 2  
next[6] = 0 // 子串'abcdabe'中没有包含以'e'结尾的连续重复子串，len = 0 

### 匹配过程与计算next的思路相似，如果当前字符不匹配，就往回跳，跳多少呢，
### <font face="黑体" color=red size=5><u>就是前面已比较串的以最后一个字符结尾的连续最长重复长度，就是next[j-1]的长度，不用再重头比较，</u></font>
### 具体看下面代码实现

## 算法实现
```
int strStr(const string& haystack, const string& needle) {
	int n = haystack.size(), m = needle.size();
	if (m == 0) return 0;
	if (n < m) return -1;

	vector<int> next(m, 0);
	// len是从起始到当前字符串中包含以当前字符结尾的重复最长连续字串长度
	// eg: abcdab---> abcdab中包含以b结尾的最长连续的重复
    // 子串为ab,所以len = 2, abcdabe len = 0, 因为没有以e结尾的连续重复子串
	for (int i = 1, len = 0; i < m; i++) {
		while (len > 0 && needle[i] != needle[len]) {
			len = next[len - 1];
		}
		if (needle[i] == needle[len]) {
			len++;
		}
		next[i] = len;
	}
    // 匹配过程，与计算next数组过程类似
	for (int i = 0, j = 0; i < n; i++) {
		while (j > 0 && haystack[i] != needle[j]) {
			j = next[j - 1];
		}
		if (haystack[i] == needle[j]) {
			j++;
		}
		if (j == m) {
			return i - m + 1;
		}
	}
	return -1;
}
```

## 总结
KMP算法的本质核心是理解如何计算模式串的next数组，匹配过程也是类似的。我们不要陷入到什么最长后缀表达式等这些概念中，一但你去纠结理解这些概念就走错了方向。我们只需要理解别人发明这个算法不容易，写成论文当然要创造些概念来多写些字，显得高大上嘛，如果一句话就告诉你本质了，评审阅读者且不是有种自己很笨的感觉吗，“我怎么没想到，原来这么简单”。论文和专利一个德行，一句话能表达清楚的，就不说人话，要把你绕进去，搞的云里雾里，显得高大上。

想到大学时期系主任说的一句让我终生受益的话：世界的道理就这么多，就看谁先想到。

任何事物、算法的本质，如果你能用一句话高度总结其核心原理，那么你才算真正的理解掌握了，在以后的工作学习生活中，你就有了把这种思维模式进行迁移，解决实际问题的可能，到了这一步就看能不能做到我系主任说的那样。
