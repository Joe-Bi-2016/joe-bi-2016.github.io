---
title: "Linux进程的Uninterruptible sleep(D)状态"
collection: system
permalink: /system/system-03
excerpt: ' '
date: 2024-09-05
citation: 'Joe-Bi. (2024). &quot;Linux进程不可中断休眠.&quot; <i>GitHub Joe-Bi of Bugs</i>'
---


### Linux进程的睡眠状态有2种：
一种是可中断睡眠，其标志位是TASK_INTERRUPTIBLE, 可中断的睡眠状态的进程会睡眠直到某个条件变为真，比如说产生一个硬件中断、释放进程正在等待的系统资源或是传递一个信号都可以是唤醒进程的条件。

一种睡眠是不可中断睡眠，其标志位是TASK_UNINTERRUPTIBLE, 信号传递到这种睡眠状态的进程不能改变它的状态，也就是除非等待的资源得到满足，否则这个进程不会变成TASK_RUNNING和进入就绪队列的。

### 定义
不可中断休眠状态是指进程在等待某个特定事件（如IO操作完成）时，进入的一种深度睡眠状态。<br />
在这种状态下，进程将不会响应任何信号（如kill信号）的唤醒请求，也不会因为其他外部事件（如中断）而被唤醒。
### 特点
深度睡眠：与可中断休眠状态（S状态）相比，不可中断休眠状态是一种更深的睡眠状态。<br />
不响应信号：处于不可中断休眠状态的进程无法被信号唤醒，即使接收到信号，这些信号也会被丢弃。<br />
等待特定事件：进程通常会在等待磁盘IO、网络IO或其他外设IO等操作时进入此状态。
### 触发条件
当进程执行某些需要长时间等待的操作（如磁盘读写、网络通信等）时，如果操作系统认为这些操作在当前无法被中断（例如，为了保证数据的完整性），则可能会将进程置于不可中断休眠状态。
### 唤醒方式
唯一能使不可中断休眠状态的进程醒来的是它等待的特定事件的完成。一旦该事件完成，进程将自动从休眠状态恢复，并继续执行其后续操作。

由上可知：不可中断休眠（Uninterruptible Sleep）是Linux操作系统中的一个概念，指的是进程的一种特殊状态。当一个进程处于不可中断休眠状态时，它是在等待某个特定的条件满足或者等待某个操作完成，在此期间它是不会响应任何中断请求的。这意味着，即使有信号发送给这个进程，它也不会醒来去处理这些信号,包括系统调用信号和其他进程信号。

### 不可中断休眠通常发生在以下两种情况下
1. 当进程执行了一个系统调用，该调用要求进程等待某个外部事件发生时。例如，当进程发起一个文件读取请求时，如果文件尚未准备好被读取，进程就会进入不可中断休眠状态，直到数据准备好为止。
2. 在一些情况下，进程可能在执行一个必须连续完成的操作，不能被打断，否则可能导致数据损坏或其他问题。例如，当内核正在更新一个共享数据结构的时候，为了保持数据的一致性，它可能会暂时进入不可中断休眠状态，确保在这个过程中没有其他进程尝试修改同样的数据。

### 导致进程进入D状态的原因
Linux系统中, 进程的D状态通常由进程等待某些资源或事件引起，这些资源或事件无法立即可用, 进程处于不可中断的睡眠状态 (Uninterruptible Sleep)。下面是一些常见的导致进程进入D状态的原因：

1. I/O 操作:
等待磁盘 I/O 完成：进程可能正在等待磁盘读取或写入操作完成。由于磁盘 I/O 操作通常需要较长时间，因此进程会进入不可中断的睡眠状态，直到 I/O 操作完成。
等待网络 I/O 完成：进程可能正在等待网络数据的接收或发送。
2. 文件系统操作:
等待文件系统锁：进程可能正在等待获取文件系统的某个锁，以便进行文件操作。
文件系统的同步操作：例如，sync 操作可能会导致进程进入 D 状态，直到所有缓冲区数据都写入磁盘。
3. 内存管理:
等待内存分页：如果系统内存不足，进程可能需要等待内存分页操作完成。
等待内存交换：在使用交换空间的情况下，进程可能需要等待交换操作完成。
4. 硬件设备:
等待硬件设备响应：进程可能正在等待某个硬件设备的响应，例如等待硬件驱动程序完成某个操作。
5. 同步原语:
等待互斥锁或信号量：进程可能正在等待其他进程释放某个互斥锁或信号量。
6. 原子性操作：
某些需要保证原子性的操作可能导致进程进入不可中断休眠状态，以防止在操作完成前被其他信号打断。

进程处于D状态时是不可中断的，这意味着即使是信号也无法唤醒该进程。D状态的存在可能表明系统正在执行某些耗时的操作，但如果进程长时间处于D状态，这可能是系统出现问题的一个信号，例如磁盘故障、硬件问题或驱动程序问题。此时可能需要进一步调查以确定问题的根本原因。

### 等待IO操作为什么会导致进程进入不可打断唤醒状态

在Linux系统中，进程在等待I/O操作或原子操作时进入不可中断的睡眠状态 (D状态)是由于以下几个原因：

1. 确保数据一致性：
当进程正在进行重要的I/O操作或原子性操作时，例如读取或写入磁盘数据，确保数据的一致性和完整性至关重要。如果进程在等待I/O操作完成时被中断，可能会导致数据不一致或损坏。因此，进程被放入不可中断的睡眠状态，以避免被信号中断。
2. 硬件依赖性：
一些I/O操作是直接与硬件设备交互的，例如磁盘读写、网络数据传输等。这些操作往往需要等待硬件设备完成相应的任务，而硬件设备的响应时间是不可预知的。将进程放入不可中断的睡眠状态，可以确保在等待硬件设备响应期间，进程不会被其他操作干扰。
3. 减少上下文切换开销：
不可中断的睡眠状态可以减少上下文切换的开销。在这种状态下，内核不会尝试频繁地唤醒和调度该进程，这样可以减少不必要的上下文切换，优化系统性能。
4. 防止资源竞争：
当进程在等待某些关键资源时，例如文件系统锁、内存分页等，不可中断的睡眠状态可以防止资源竞争和死锁情况的发生。这样可以确保系统在处理这些关键资源时的稳定性。
5. 内核实现机制：
内核在设计时，有些I/O操作被实现为不可中断的睡眠状态，这是由于这些操作的复杂性和关键性。例如，在处理磁盘I/O时，内核需要保证数据的一致性和完整性，因此选择将进程放入不可中断的睡眠状态。

总结来说，进程在等待I/O操作或原子性操作时进入不可中断的睡眠状态，是为了确保数据一致性和系统稳定性，减少上下文切换开销，防止资源竞争，并符合内核设计的实现机制。尽管这种状态有时可能导致系统响应变慢，但它在确保系统可靠性和数据完整性方面起到了重要作用。

